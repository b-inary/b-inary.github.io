<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An open-source postflop solver library."><meta name="keywords" content="rust, rustlang, rust-lang, postflop_solver"><title>postflop_solver - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9def1262ebc682c9.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../static.files/ayu-94f39d4346842c1e.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../postflop_solver/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../postflop_solver/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate postflop_solver</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">postflop_solver</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/postflop_solver/lib.rs.html#1-184">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An open-source postflop solver library.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>postflop_solver::<span class="kw-2">*</span>;

<span class="comment">// ranges of OOP and IP in string format
</span><span class="kw">let </span>oop_range = <span class="string">&quot;66+,A8s+,A5s-A4s,AJo+,K9s+,KQo,QTs+,JTs,96s+,85s+,75s+,65s,54s&quot;</span>;
<span class="kw">let </span>ip_range = <span class="string">&quot;QQ-22,AQs-A2s,ATo+,K5s+,KJo+,Q8s+,J8s+,T7s+,96s+,86s+,75s+,64s+,53s+&quot;</span>;

<span class="kw">let </span>card_config = CardConfig {
    range: [oop_range.parse().unwrap(), ip_range.parse().unwrap()],
    flop: flop_from_str(<span class="string">&quot;Td9d6h&quot;</span>).unwrap(),
    turn: card_from_str(<span class="string">&quot;Qc&quot;</span>).unwrap(),
    river: NOT_DEALT,
};

<span class="comment">// bet sizes -&gt; 60% of the pot, geometric size, and all-in
// raise sizes -&gt; 2.5x of the previous bet
// see the documentation of `BetSizeCandidates` for more details
</span><span class="kw">let </span>bet_sizes = BetSizeCandidates::try_from((<span class="string">&quot;60%, e, a&quot;</span>, <span class="string">&quot;2.5x&quot;</span>)).unwrap();

<span class="kw">let </span>tree_config = TreeConfig {
    initial_state: BoardState::Turn,
    starting_pot: <span class="number">200</span>,
    effective_stack: <span class="number">900</span>,
    rake_rate: <span class="number">0.0</span>,
    rake_cap: <span class="number">0.0</span>,
    flop_bet_sizes: [bet_sizes.clone(), bet_sizes.clone()], <span class="comment">// [OOP, IP]
    </span>turn_bet_sizes: [bet_sizes.clone(), bet_sizes.clone()],
    river_bet_sizes: [bet_sizes.clone(), bet_sizes.clone()],
    turn_donk_sizes: <span class="prelude-val">None</span>, <span class="comment">// use default bet sizes
    </span>river_donk_sizes: <span class="prelude-val">Some</span>(DonkSizeCandidates::try_from(<span class="string">&quot;50%&quot;</span>).unwrap()),
    add_allin_threshold: <span class="number">1.5</span>, <span class="comment">// add all-in if (maximum bet size) &lt;= 1.5x pot
    </span>force_allin_threshold: <span class="number">0.15</span>, <span class="comment">// force all-in if (SPR after the opponent&#39;s call) &lt;= 0.15
    </span>merging_threshold: <span class="number">0.1</span>,
};

<span class="comment">// build the game tree
</span><span class="kw">let </span>action_tree = ActionTree::new(tree_config).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>game = PostFlopGame::with_config(card_config, action_tree).unwrap();

<span class="comment">// obtain the private hands
</span><span class="kw">let </span>oop_hands = game.private_cards(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(card_to_string(oop_hands[<span class="number">0</span>].<span class="number">0</span>).unwrap(), <span class="string">&quot;4c&quot;</span>);
<span class="macro">assert_eq!</span>(card_to_string(oop_hands[<span class="number">0</span>].<span class="number">1</span>).unwrap(), <span class="string">&quot;5c&quot;</span>);

<span class="comment">// check memory usage
</span><span class="kw">let </span>(mem_usage, mem_usage_compressed) = game.memory_usage();
<span class="macro">println!</span>(
    <span class="string">&quot;Memory usage without compression: {:.2}GB&quot;</span>,
    mem_usage <span class="kw">as </span>f64 / (<span class="number">1024.0 </span>* <span class="number">1024.0 </span>* <span class="number">1024.0</span>)
);
<span class="macro">println!</span>(
    <span class="string">&quot;Memory usage with compression: {:.2}GB&quot;</span>,
    mem_usage_compressed <span class="kw">as </span>f64 / (<span class="number">1024.0 </span>* <span class="number">1024.0 </span>* <span class="number">1024.0</span>)
);

<span class="comment">// allocate memory without compression
</span>game.allocate_memory(<span class="bool-val">false</span>);

<span class="comment">// allocate memory with compression
// game.allocate_memory(true);

// solve the game
</span><span class="kw">let </span>max_num_iterations = <span class="number">1000</span>;
<span class="kw">let </span>target_exploitability = game.tree_config().starting_pot <span class="kw">as </span>f32 * <span class="number">0.005</span>;
<span class="kw">let </span>exploitability = solve(<span class="kw-2">&amp;mut </span>game, max_num_iterations, target_exploitability, <span class="bool-val">true</span>);
<span class="macro">println!</span>(<span class="string">&quot;Exploitability: {:.2}&quot;</span>, exploitability);

<span class="comment">// solve the game manually
// for i in 0..max_num_iterations {
//     solve_step(&amp;game, i);
//     if (i + 1) % 10 == 0 {
//         let exploitability = compute_mes_ev_average(&amp;game);
//         if exploitability &lt;= target_exploitability {
//             println!(&quot;Exploitability: {:.2}&quot;, exploitability);
//             break;
//         }
//     }
// }
// finalize(&amp;mut game);

// get equity and EV of a specific hand
</span>game.cache_normalized_weights();
<span class="kw">let </span>equity = game.equity(<span class="number">0</span>); <span class="comment">// `0` means OOP player
</span><span class="kw">let </span>ev = game.expected_values(<span class="number">0</span>);
<span class="macro">println!</span>(<span class="string">&quot;Equity of oop_hands[0]: {:.2}%&quot;</span>, <span class="number">100.0 </span>* equity[<span class="number">0</span>]);
<span class="macro">println!</span>(<span class="string">&quot;EV of oop_hands[0]: {:.2}&quot;</span>, ev[<span class="number">0</span>]);

<span class="comment">// get equity and EV of whole hand
</span><span class="kw">let </span>weights = game.normalized_weights(<span class="number">0</span>);
<span class="kw">let </span>average_equity = compute_average(<span class="kw-2">&amp;</span>equity, weights);
<span class="kw">let </span>average_ev = compute_average(<span class="kw-2">&amp;</span>ev, weights);
<span class="macro">println!</span>(<span class="string">&quot;Average equity: {:.2}%&quot;</span>, <span class="number">100.0 </span>* average_equity);
<span class="macro">println!</span>(<span class="string">&quot;Average EV: {:.2}&quot;</span>, average_ev);

<span class="comment">// get available actions (OOP)
</span><span class="kw">let </span>actions = game.available_actions();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:?}&quot;</span>, actions), <span class="string">&quot;[Check, Bet(120), Bet(216), AllIn(900)]&quot;</span>);

<span class="comment">// play `Bet(120)`
</span>game.play(<span class="number">1</span>);

<span class="comment">// get available actions (IP)
</span><span class="kw">let </span>actions = game.available_actions();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:?}&quot;</span>, actions), <span class="string">&quot;[Fold, Call, Raise(300)]&quot;</span>);

<span class="comment">// play `Call`
</span>game.play(<span class="number">1</span>);

<span class="comment">// confirm that the current node is a chance node (i.e., river node)
</span><span class="macro">assert!</span>(game.is_chance_node());

<span class="comment">// confirm that &quot;7s&quot; may be dealt
</span><span class="kw">let </span>card_7s = card_from_str(<span class="string">&quot;7s&quot;</span>).unwrap();
<span class="macro">assert!</span>(game.possible_cards() &amp; (<span class="number">1 </span>&lt;&lt; card_7s) != <span class="number">0</span>);

<span class="comment">// deal &quot;7s&quot;
</span>game.play(card_7s <span class="kw">as </span>usize);

<span class="comment">// back to the root node
</span>game.back_to_root();</code></pre></div>
<h2 id="implementation-details"><a href="#implementation-details">Implementation details</a></h2>
<ul>
<li><strong>Algorithm</strong>: The solver uses <a href="https://arxiv.org/abs/1809.04040">Discounted CFR</a> algorithm.
Currently, the value of γ is set to 5.0, rather than the 2.0 recommended by the original paper.</li>
<li><strong>Precision</strong>: 32-bit floating-point numbers are used in most places.
When calculating summations, temporal values use 64-bit floating-point numbers.
If the compression feature is enabled, each game node stores the values by 16-bit integers
with a single 32-bit floating-point scaling factor.</li>
<li><strong>Handling isomorphism</strong>: The solver does not perform any abstraction.
However, isomorphic chances (turn and river deals) are combined into one.
For example, if the flop is monotone, the three non-dealt suits are isomorphic,
allowing us to skip the calculation for two of the three suits.</li>
</ul>
<h2 id="crate-features"><a href="#crate-features">Crate features</a></h2>
<ul>
<li><code>bincode</code>: Uses <a href="https://github.com/bincode-org/bincode">bincode</a> crate (2.0.0-rc.2) to serialize and deserialize the <code>PostFlopGame</code> struct.
Disabled by default.</li>
<li><code>custom-alloc</code>: Uses custom memory allocator in solving process (only available in nightly Rust).
It significantly reduces the number of calls of the default allocator,
so it is recommended to use this feature when the default allocator is not so efficient.
Note that this feature assumes that, at most, only one instance of <code>PostFlopGame</code> is available
when solving in a program.
Disabled by default.</li>
<li><code>rayon</code>: Uses <a href="https://github.com/rayon-rs/rayon">rayon</a> crate for parallelization.
Enabled by default.</li>
</ul>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ActionTree.html" title="postflop_solver::ActionTree struct">ActionTree</a></div><div class="item-right docblock-short">A struct representing an abstract game tree.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BetSizeCandidates.html" title="postflop_solver::BetSizeCandidates struct">BetSizeCandidates</a></div><div class="item-right docblock-short">Bet size candidates for the first bets and raises.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.CardConfig.html" title="postflop_solver::CardConfig struct">CardConfig</a></div><div class="item-right docblock-short">A struct containing the card configuration.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.DonkSizeCandidates.html" title="postflop_solver::DonkSizeCandidates struct">DonkSizeCandidates</a></div><div class="item-right docblock-short">Bet size candidates for the donk bets.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MutexGuardLike.html" title="postflop_solver::MutexGuardLike struct">MutexGuardLike</a></div><div class="item-right docblock-short">Smart pointer like wrapper that is returned when <a href="struct.MutexLike.html" title="MutexLike"><code>MutexLike</code></a> is “locked”.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MutexLike.html" title="postflop_solver::MutexLike struct">MutexLike</a></div><div class="item-right docblock-short">Mutex-like wrapper, but it actually does not perform any locking.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PostFlopGame.html" title="postflop_solver::PostFlopGame struct">PostFlopGame</a></div><div class="item-right docblock-short">A struct representing a postflop game.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PostFlopNode.html" title="postflop_solver::PostFlopNode struct">PostFlopNode</a></div><div class="item-right docblock-short">A struct representing a node in a postflop game tree.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Range.html" title="postflop_solver::Range struct">Range</a></div><div class="item-right docblock-short">A struct representing a player’s range.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TreeConfig.html" title="postflop_solver::TreeConfig struct">TreeConfig</a></div><div class="item-right docblock-short">A struct containing the game tree configuration.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Action.html" title="postflop_solver::Action enum">Action</a></div><div class="item-right docblock-short">Available actions of the postflop game.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.BetSize.html" title="postflop_solver::BetSize enum">BetSize</a></div><div class="item-right docblock-short">Bet size specification.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.BoardState.html" title="postflop_solver::BoardState enum">BoardState</a></div><div class="item-right docblock-short">An enum representing the board state.</div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.NOT_DEALT.html" title="postflop_solver::NOT_DEALT constant">NOT_DEALT</a></div><div class="item-right docblock-short">Constant representing that the card is not yet dealt.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Game.html" title="postflop_solver::Game trait">Game</a></div><div class="item-right docblock-short">The trait representing a game.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.GameNode.html" title="postflop_solver::GameNode trait">GameNode</a></div><div class="item-right docblock-short">The trait representing a node in game tree.</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.card_from_chars.html" title="postflop_solver::card_from_chars fn">card_from_chars</a></div><div class="item-right docblock-short">Attempts to read the next card from a char iterator.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.card_from_str.html" title="postflop_solver::card_from_str fn">card_from_str</a></div><div class="item-right docblock-short">Attempts to convert a string into a card.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.card_to_string.html" title="postflop_solver::card_to_string fn">card_to_string</a></div><div class="item-right docblock-short">Attempts to convert a card into a string.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.compute_average.html" title="postflop_solver::compute_average fn">compute_average</a></div><div class="item-right docblock-short">Computes the average with given weights.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.compute_current_ev_average.html" title="postflop_solver::compute_current_ev_average fn">compute_current_ev_average</a></div><div class="item-right docblock-short">Computes the average of the expected values of the current strategy.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.compute_mes_ev_average.html" title="postflop_solver::compute_mes_ev_average fn">compute_mes_ev_average</a></div><div class="item-right docblock-short">Computes the average of the expected values of the MES (Maximally Exploitative Strategy).</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.finalize.html" title="postflop_solver::finalize fn">finalize</a></div><div class="item-right docblock-short">Finalizes the solving process.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.flop_from_str.html" title="postflop_solver::flop_from_str fn">flop_from_str</a></div><div class="item-right docblock-short">Attempts to convert an optionally space-separated string into a sorted flop array.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.solve.html" title="postflop_solver::solve fn">solve</a></div><div class="item-right docblock-short">Performs Discounted CFR algorithm until the given number of iterations or exploitability is
satisfied.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.solve_step.html" title="postflop_solver::solve_step fn">solve_step</a></div><div class="item-right docblock-short">Proceeds Discounted CFR algorithm for one iteration.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="postflop_solver" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (bdb07a8ec 2022-12-11)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>